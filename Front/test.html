<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Visualizer Controller</title>
    <style>
body{
    overflow: hidden;
}
iframe{
    position: absolute;
    top: 0px;
    left: 0;
    z-index: -1;
    height: 99vh;
    border: none;
}
    </style>
</head>
<body>
    
    <!-- <h1>Control Particle Visualizer</h1> -->
    
    <!-- Sliders for controlling height and threshold -->
    <label for="heightSlider">Height Scale:</label>
    <input type="range" id="heightSlider" min="-10" max="10" step="0.02" value="0.1" />
    <span id="heightValue">5</span>
    
    <br>
    
    <label for="thresholdSlider">Threshold:</label>
    <input type="range" id="thresholdSlider" min="0" max="1" step="0.01" value="0.1" />
    <span id="thresholdValue">0.7</span>

    <br>

    <label for="noiseAmountSlider">Noise Amount:</label>
    <input type="range" id="noiseAmountSlider" min="0" max="1" step="0.05" value="0.1" />
    <span id="noiseAmountValue">0.1</span>

    <br>
    <br>

    <!-- Button to trigger randomization -->
    <button onclick="randomizeSliders()" style="height: 35px;">Randomize Sliders</button>


    <!-- Button for downloading frame -->
    <button id="downloadButton"  style="height: 35px;" >Download Frame</button>

    <!-- Audio element to play the song -->
    <audio id="audioPlayer" controls>
        <source src="http://127.0.0.1:5502/threejs-webcam-particle-visualizer-master/threejs-webcam-particle-visualizer-master/s.mp3" type="audio/mp3">
        Your browser does not support the audio element.
    </audio>

    <!-- Iframe to load the particle visualizer -->
    <iframe id="particleFrame" src="Particle/index.html" width="100%" height="500px"></iframe>

    <script>
        // Elements
        
        const heightSlider = document.getElementById("heightSlider");
        const thresholdSlider = document.getElementById("thresholdSlider");
        const downloadButton = document.getElementById("downloadButton");
        const audioPlayer = document.getElementById("audioPlayer");
        const noiseAmountSlider = document.getElementById("noiseAmountSlider");

        // Function to send the height scale and threshold values to iframe
        const updateIframe = () => {
            const heightValue = heightSlider.value;
            const thresholdValue = thresholdSlider.value;
            const noiseAmountValue = noiseAmountSlider.value;

            // Send data to the iframe
            const iframe = document.getElementById('particleFrame');
            iframe.contentWindow.postMessage({ type: 'setHeight', value: heightValue }, '*');
            iframe.contentWindow.postMessage({ type: 'setThreshold', value: thresholdValue }, '*');
            iframe.contentWindow.postMessage({ type: 'setNoiseAmount', value: noiseAmountValue }, '*'); // Set noise amount

            // Update display values
            document.getElementById('heightValue').textContent = heightValue;
            document.getElementById('thresholdValue').textContent = thresholdValue;
            document.getElementById('noiseAmountValue').textContent = noiseAmountValue; // Update noise amount value
        };


        // Event listeners for the sliders
        heightSlider.addEventListener('input', updateIframe);
        thresholdSlider.addEventListener('input', updateIframe);
        // Event listener for the noise amount slider
        noiseAmountSlider.addEventListener('input', updateIframe);

        // Capture and download the iframe's current frame
        const captureIframeFrame = () => {
            const iframe = document.getElementById('particleFrame');
            if (!iframe || !iframe.contentWindow) {
                alert('Iframe not ready');
                return;
            }

            // Listen for the captured frame
            const onMsg = (ev) => {
                if (ev.source !== iframe.contentWindow) return;
                if (!ev.data || ev.data.type !== 'frame') return;

                window.removeEventListener('message', onMsg);

                const { dataUrl } = ev.data;
                if (!dataUrl) {
                    alert('No image returned');
                    return;
                }

                // Download the image
                const a = document.createElement('a');
                a.href = dataUrl;
                a.download = 'iframe-frame.png';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            };

            window.addEventListener('message', onMsg);

            // Ask the iframe to capture its current frame
            iframe.contentWindow.postMessage({ type: 'captureFrame' }, '*');
        };

        // Event listener for the download button
        downloadButton.addEventListener('click', captureIframeFrame);

        // Initial update on load
        updateIframe();

        // Hardcoded Kick and Snare timings (in seconds)
        const kickTimes = [
            6.357, 9.082, 9.245, 9.422, 10.398, 10.980, 11.565, 11.662, 11.797, 12.398, 15.318, 15.480, 
            15.693, 16.630, 16.725, 17.215, 17.310, 17.793, 17.887, 18.225, 18.582, 21.550, 21.713, 21.890, 
            22.865, 23.448, 23.545, 24.025, 24.120, 24.265, 24.817, 27.773, 27.948, 28.125, 29.098, 29.683, 
            30.260, 30.355, 30.500, 31.050, 34.358, 35.333, 35.903, 36.002, 36.495, 36.587, 36.733, 37.123, 
            40.240, 40.415, 41.560, 41.653, 42.142, 42.238, 42.727, 42.822, 42.968, 43.163, 43.568, 46.475, 
            46.648, 46.888, 47.793, 47.888, 48.377, 48.470, 48.962, 49.055, 49.200, 49.760, 52.720, 52.883, 
            53.098, 54.032, 54.127, 54.617, 55.195, 55.290, 55.433, 56.035, 56.212, 58.943, 59.115, 59.330, 
            60.260, 60.355, 60.845, 60.938, 61.435, 61.648, 62.267, 65.175, 65.350, 65.563, 66.500, 67.085, 
            67.670, 67.903, 68.502
        ];

        const snareTimes = [
            0.855, 3.970, 6.808, 8.180, 8.610, 9.643, 10.127, 11.230, 11.730, 12.873, 14.130, 14.803, 16.438, 
            17.398, 17.650, 19.555, 21.095, 22.675, 23.428, 23.760, 24.230, 24.602, 26.887, 27.350, 27.670, 
            28.915, 29.668, 31.588, 35.142, 38.255, 38.553, 39.815, 41.383, 41.800, 42.580, 43.208, 44.490, 
            46.047, 46.355, 47.610, 49.160, 49.955, 52.285, 53.837, 55.398, 56.142, 56.958, 58.458, 60.072, 
            62.990, 63.970, 64.758, 65.267, 66.313
        ];
        // Function to animate sliders
        function animateController(slider, startValue, endValue, duration, delay = 0) {
            const startTime = performance.now() + delay;  // Add delay to the start time
            const easeOutQuad = (t) => t * (2 - t); // Easing function for smooth transition

            function animate() {
                const elapsedTime = performance.now() - startTime;
                const progress = Math.min(elapsedTime / duration, 1); // Ensure the progress doesn't go beyond 1

                // Calculate the current value with easing
                const easedProgress = easeOutQuad(progress);
                const currentValue = startValue + (endValue - startValue) * easedProgress;

                slider.value = currentValue.toFixed(2); // Set the slider value
                updateIframe(); // Update the iframe with the new value

                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }

            animate(); // Start the animation
        }

        // Function to start animations based on the audio player's current time
        function startAnimationOnAudio() {
            const audioDuration = audioPlayer.duration;
            let delay = 0;  // Initialize delay

            // Loop through kick times and snare times to trigger animations
            kickTimes.forEach(kickTime => {
                const delayTime = (kickTime - audioPlayer.currentTime) * 1000 + delay; // Convert to milliseconds and add delay
                setTimeout(() => {
                    animateController(heightSlider, 5, 7, 200);  // Animate height slider on kick
                }, delayTime);
            });

            snareTimes.forEach(snareTime => {
                const delayTime = (snareTime - audioPlayer.currentTime) * 1000 + delay; // Convert to milliseconds and add delay
                setTimeout(() => {
                    animateController(noiseAmountSlider, 0.0, 0.61, 300);  // Animate threshold slider on snare
                }, delayTime);
            });
        }

        // Start animations when the audio starts playing
        audioPlayer.addEventListener('play', startAnimationOnAudio);

        // Optional: Tune the lag (for earlier or later triggering)
        // For example, adjust the delay value to speed up or delay the triggering:
        const delayAdjustment = 0;  // 0 for no adjustment, positive for later, negative for sooner
                        function animateController(slider, startValue, endValue, duration) {
            const startTime = performance.now();
            const easeOutQuad = (t) => t * (2 - t); // Easing function for smooth transition

            function animate() {
                const elapsedTime = performance.now() - startTime;
                const progress = Math.min(elapsedTime / duration, 1); // Ensure the progress doesn't go beyond 1

                // Calculate the current value with easing
                const easedProgress = easeOutQuad(progress);
                const currentValue = startValue + (endValue - startValue) * easedProgress;

                slider.value = currentValue.toFixed(2); // Set the slider value
                updateIframe(); // Update the iframe with the new value

                if (progress < 1) {
                    requestAnimationFrame(animate);
                }
            }

            animate(); // Start the animation
        }

        // Trigger on page load to animate sliders from a to b
        window.onload = () => {
            setTimeout(() => {
                // Animate height slider from 5 to 8 over 3 seconds
                animateController(heightSlider, 0.1, 2, 3000);

                // Animate threshold slider from 0.7 to 0.4 over 3 seconds
                animateController(thresholdSlider, 0.1, 0.8, 2000);
                // animateController(noiseAmountSlider, 0.1, 0.1, 100);

                
                const iframe = document.getElementById('particleFrame');

                iframe.contentWindow.postMessage({ type: 'setNoiseAmount', value: 0.9 }, '*');

            }, 1000);



        };
        function randomizeSliders() {
            // Random target values for sliders
            const heightRandom = (Math.random()-0.5) * 20;
            const thresholdRandom = (Math.random()+0.2)/1.2; // Between 0 and 1
            const noiseRandom = (Math.random())*0.9; // Between 0 and 1

            // Animate sliders to new random values
            animateController(heightSlider, parseFloat(heightSlider.value), heightRandom, 1000);
            animateController(thresholdSlider, parseFloat(thresholdSlider.value), thresholdRandom, 1000);
            animateController(noiseAmountSlider, parseFloat(noiseAmountSlider.value), noiseRandom, 1000);
        
        }
    </script>


<!-- audio source controls -->
<div id="audio-reactive-ui" style="display:flex;gap:8px;align-items:center;">
  <input type="file" id="songFile" accept="audio/*">
  <button id="playPauseBtn" disabled>Play</button>
  <button id="useMicBtn">Use Mic</button>
  <span id="reactiveStatus" style="opacity:.8;">idle</span>
</div>

<!-- hidden audio element used for file playback -->
<audio id="songPlayer"  preload="auto" crossorigin="anonymous" playsinline></audio>
<div class="flex flex-col gap-2" id="genre-controls">
  <button class="btn btn-outline genre-btn w-full text-right" data-genre="techno">Techno | تکنو</button>
  <button class="btn btn-outline genre-btn w-full text-right" data-genre="ambient">Ambient | امبینت</button>
  <button class="btn btn-outline genre-btn w-full text-right" data-genre="electronic">Electronic | الکترونیک</button>
  <button class="btn btn-outline genre-btn w-full text-right" data-genre="house">House | هاوس</button>
</div>

<!-- four dedicated audio elements for fast switching -->
<audio id="audio-techno" preload="auto" crossorigin="anonymous" playsinline></audio>
<audio id="audio-ambient" preload="auto" crossorigin="anonymous" playsinline></audio>
<audio id="audio-electronic" preload="auto" crossorigin="anonymous" playsinline></audio>
<audio id="audio-house" preload="auto" crossorigin="anonymous" playsinline></audio>

<script>
//


// ===== helpers: get your existing slider elements =====

// required: your existing function
// function animateController(sliderEl, fromValue, toValue, durationMs) { ... }

// ===== core: simple audio-reactive engine =====
class AudioReactiveEngine {
  constructor({ onKick, onSnare, onLoudness, statusEl }) {
    this.onKick = onKick;
    this.onSnare = onSnare;
    this.onLoudness = onLoudness;
    this.statusEl = statusEl;



    // keep these properties in the constructor:
    this.mediaNodeMap = new WeakMap(); // HTMLMediaElement -> MediaElementAudioSourceNode
    this.currentMediaEl = null;



    this.ctx = null;
    this.src = null;
    this.analyser = null;
    this.freqData = null;
    this.timeData = null;
    this.raf = null;

    // detection state
    this.kickEnv = 0;
    this.snareEnv = 0;
    this.loudnessEnv = 0;
    this.kickHold = 0;
    this.snareHold = 0;

    this.sampleRate = 44100;
    this.fftSize = 2048;

    // thresholds (tweakable)
    this.kickThreshold = 0.3;
    this.snareThreshold = 0.25;
    this.loudSmooth = 0.9;   // 0..1, higher = smoother (EMA)
    this.envDecay = 0.75;    // beat envelope decay per frame
    this.holdFrames = 6;     // min frames between same-hit triggers
  }

  _ensureCtx() {
    if (!this.ctx) {
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      this.sampleRate = this.ctx.sampleRate;
      this.analyser = this.ctx.createAnalyser();
      this.analyser.fftSize = this.fftSize;
      this.analyser.smoothingTimeConstant = 0.75;
      this.freqData = new Uint8Array(this.analyser.frequencyBinCount);
      this.timeData = new Uint8Array(this.analyser.fftSize);
    }
  }

// Inside class AudioReactiveEngine { ... }


// REPLACE your old useFile() with this:
async useFile(audioEl) {
  this._ensureCtx();
  if (this.ctx.state === 'suspended') await this.ctx.resume();

  // 1) Disconnect previous media node from analyser (leave destination alone)
  if (this.currentMediaEl && this.mediaNodeMap.has(this.currentMediaEl)) {
    try { this.mediaNodeMap.get(this.currentMediaEl).disconnect(); } catch {}
  }

  // 2) Get or create (once) a MediaElementSource for this element
  let srcNode = this.mediaNodeMap.get(audioEl);
  if (!srcNode) {
    srcNode = this.ctx.createMediaElementSource(audioEl);
    this.mediaNodeMap.set(audioEl, srcNode);
  }

  // 3) Route: element -> analyser  (analyser -> destination already set elsewhere)
  try { srcNode.disconnect(); } catch {}           // ensure clean
  srcNode.connect(this.analyser);

  // 4) Ensure analyser -> destination is connected exactly once
  // (safe to call repeatedly)
  try { this.analyser.disconnect(); } catch {}
  this.analyser.connect(this.ctx.destination);

  this.currentMediaEl = audioEl;

  if (!this.raf) this._startLoop();
  this._setStatus('file • ready');
}


  async useMic() {
    this.stop();
    this._ensureCtx();
    if (this.ctx.state === 'suspended') await this.ctx.resume();
    const stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false } });
    this.src = this.ctx.createMediaStreamSource(stream);
    this.src.connect(this.analyser);
    this._startLoop();
    this._setStatus('mic • live');
  }

  stop() {
    if (this.raf) cancelAnimationFrame(this.raf);
    this.raf = null;
    try { this.src && this.src.disconnect(); } catch {}
    this.src = null;
    this._setStatus('idle');
  }

  _binForHz(hz) {
    // analyser frequencyBinCount = fftSize/2
    const nyquist = this.sampleRate / 2;
    return Math.max(0, Math.min(this.analyser.frequencyBinCount - 1, Math.round(hz / nyquist * this.analyser.frequencyBinCount)));
  }

  _bandEnergy(hzLo, hzHi) {
    const lo = this._binForHz(hzLo);
    const hi = this._binForHz(hzHi);
    let sum = 0;
    for (let i = lo; i <= hi; i++) sum += this.freqData[i] / 255;
    return sum / Math.max(1, (hi - lo + 1));
  }

  _fullbandRMS() {
    // quick RMS from time domain 0..255
    this.analyser.getByteTimeDomainData(this.timeData);
    let acc = 0;
    for (let i = 0; i < this.timeData.length; i++) {
      const v = (this.timeData[i] - 128) / 128;
      acc += v * v;
    }
    return Math.sqrt(acc / this.timeData.length); // ~0..1
  }

  _startLoop() {
    const loop = () => {
      this.analyser.getByteFrequencyData(this.freqData);

      // loudness (full-band RMS)
      const rms = this._fullbandRMS();
      this.loudnessEnv = this.loudnessEnv * this.loudSmooth + rms * (1 - this.loudSmooth);

      // kick: low band ~ 30–150 Hz
      const kickEnergy = this._bandEnergy(30, 150);
      this.kickEnv = Math.max(kickEnergy, this.kickEnv * this.envDecay);

      // snare: mid-high band ~ 1.5–4.5 kHz
      const snareEnergy = this._bandEnergy(1500, 4500);
      this.snareEnv = Math.max(snareEnergy, this.snareEnv * this.envDecay);

      // triggers with simple hysteresis + hold
      if (this.kickHold <= 0 && kickEnergy - this.kickEnv * 0.6 > this.kickThreshold) {
        this.kickHold = this.holdFrames;
        this.onKick && this.onKick(kickEnergy);
      } else {
        this.kickHold--;
      }

      if (this.snareHold <= 0 && snareEnergy - this.snareEnv * 0.6 > this.snareThreshold) {
        this.snareHold = this.holdFrames;
        this.onSnare && this.onSnare(snareEnergy);
      } else {
        this.snareHold--;
      }

      // continuous loudness callback (0..1)
      this.onLoudness && this.onLoudness(this.loudnessEnv);

      this.raf = requestAnimationFrame(loop);
    };
    this.raf = requestAnimationFrame(loop);
  }

  _setStatus(t) { if (this.statusEl) this.statusEl.textContent = t; }
}

// ===== mapping: randomly pair metrics -> controllers, reshuffle every N seconds =====
(function setupReactive() {
  const audioEl = document.getElementById('songPlayer');
  const fileInput = document.getElementById('songFile');
  const playBtn = document.getElementById('playPauseBtn');
  const micBtn = document.getElementById('useMicBtn');
  const statusEl = document.getElementById('reactiveStatus');

  // clamp + random helpers
  const rand = (min, max) => min + Math.random() * (max - min);
  const clamp = (v, a, b) => Math.min(b, Math.max(a, v));
  const mapRange = (v, inMin, inMax, outMin, outMax) => outMin + (clamp(v, inMin, inMax) - inMin) * (outMax - outMin) / (inMax - inMin);

  // controller ranges you asked for
  const ranges = {
    height:   { min: -10, max: 10, dur: 200 },
    threshold:{ min: 0.1, max: 0.9, dur: 300 },
    noise:    { min: 0.1, max: 0.9, dur: 100 },
  };

  // build three controller updaters
  const controllers = {
    height(val, fast=false) {
      const from = parseFloat(heightSlider?.value ?? 0);
      const to = clamp(val, ranges.height.min, ranges.height.max);
      animateController(heightSlider, from, to, fast ? 120 : ranges.height.dur);
    },
    threshold(val, fast=false) {
      const from = parseFloat(thresholdSlider?.value ?? 0.5);
      const to = clamp(val, ranges.threshold.min, ranges.threshold.max);
      animateController(thresholdSlider, from, to, fast ? 140 : ranges.threshold.dur);
    },
    noise(val, fast=false) {
      const from = parseFloat(noiseAmountSlider?.value ?? 0.5);
      const to = clamp(val, ranges.noise.min, ranges.noise.max);
      animateController(noiseAmountSlider, from, to, fast ? 100 : ranges.noise.dur);
    }
  };

  // metrics -> controllers mapping that reshuffles periodically
  const metrics = ['kick','snare','loudness'];
  const controllerKeys = ['height','threshold','noise'];
  let mapping = {};
  let lastShuffle = 0;
  const shuffleIntervalMs = 10000;

  function shuffleMapping() {
    const shuffled = controllerKeys.slice().sort(() => Math.random() - 0.5);
    mapping.kick = shuffled[0];
    mapping.snare = shuffled[1];
    mapping.loudness = shuffled[2];
    lastShuffle = performance.now();
    statusEl.textContent = `map: kick→${mapping.kick}, snare→${mapping.snare}, loudness→${mapping.loudness}`;
  }
  shuffleMapping();

  // beat to controller actions
  const onKick = (energy) => {
    if (performance.now() - lastShuffle > shuffleIntervalMs) shuffleMapping();
    const target = mapping.kick;
    const toVal = rand(ranges[target === 'height' ? 'height' : target].min, ranges[target === 'height' ? 'height' : target].max);
    controllers[target](toVal, true);
  };

  const onSnare = (energy) => {
    if (performance.now() - lastShuffle > shuffleIntervalMs) shuffleMapping();
    const target = mapping.snare;
    const toVal = rand(ranges[target === 'height' ? 'height' : target].min, ranges[target === 'height' ? 'height' : target].max);
    controllers[target](toVal, true);
  };

  const onLoudness = (lvl) => {
    // smooth follow: map 0..1 loudness into appropriate range
    const target = mapping.loudness;
    const r = ranges[target === 'height' ? 'height' : target];
    const toVal = mapRange(lvl, 0.05, 0.35, r.min, r.max);
    controllers[target](toVal, false);
  };

  const engine = new AudioReactiveEngine({ onKick, onSnare, onLoudness, statusEl });

  // ui wiring
  fileInput.addEventListener('change', async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    // play locally without “downloading”
    audioEl.src = URL.createObjectURL(file);
    audioEl.onloadedmetadata = () => { playBtn.disabled = false; statusEl.textContent = 'file • loaded'; };
    await engine.useFile(audioEl);
  });

  playBtn.addEventListener('click', async () => {
    if (audioEl.paused) {
      try { await audioEl.play(); playBtn.textContent = 'Pause'; statusEl.textContent = 'playing'; }
      catch (e) { console.warn(e); }
    } else {
      audioEl.pause(); playBtn.textContent = 'Play'; statusEl.textContent = 'paused';
    }
  });

  micBtn.addEventListener('click', async () => {
    try {
      await engine.useMic();
      playBtn.textContent = 'Play';
      playBtn.disabled = true;
      if (!audioEl.paused) audioEl.pause();
    } catch (e) {
      statusEl.textContent = 'mic denied';
      console.warn('mic error', e);
    }
  });

  // optional: reshuffle mapping on spacebar
  window.addEventListener('keydown', (ev) => {
    if (ev.code === 'Space') { ev.preventDefault(); shuffleMapping(); }
  });
})();







// ===== song libraries per genre (swap with your own links; must be CORS-allowed) =====
const SONGS = {
  techno: [
    'https://testsong.b-cdn.net/Tiem - 8 Khat.mp3',
    // 'https://your.cdn/techno/track2.mp3',
  ],
  ambient: [
    'https://testsong.b-cdn.net/m.mp3',
  ],
  electronic: [
    'https://testsong.b-cdn.net/Keshidi Par - Chvrsi..mp3',
  ],
  house: [
    'https://testsong.b-cdn.net/Yechi Bede Dod konm (320).mp3',
  ],
};

// quick helpers
const randIdx = (arr) => Math.floor(Math.random() * arr.length);
const byId = (id) => document.getElementById(id);


// === Blob loader: prevents IDM intercepting direct MP3 links ===
async function toBlobUrl(fileUrl, mime = 'audio/mpeg') {
  const res = await fetch(fileUrl, { credentials: 'omit', cache: 'force-cache' });
  if (!res.ok) throw new Error(`Failed to fetch audio ${res.status}`);
  const buf = await res.arrayBuffer();
  const blob = new Blob([buf], { type: mime });
  return URL.createObjectURL(blob);
}

async function loadTrackToAudioEl(audioEl, fileUrl, mime='audio/mpeg') {
  if (audioEl._objectUrl) { try { URL.revokeObjectURL(audioEl._objectUrl); } catch {} }
  const objUrl = await toBlobUrl(fileUrl, mime);
  audioEl.src = objUrl;
  audioEl._objectUrl = objUrl;
  audioEl.setAttribute('controlslist', 'nodownload noplaybackrate');
  audioEl.preload = 'auto';
}

// helper to pick & set a random song for a genre
async function setRandomTrack(genre) {
  const el = audioEls[genre];
  const list = SONGS[genre] || [];
  if (!list.length) return;
  const url = list[Math.floor(Math.random() * list.length)];
  await loadTrackToAudioEl(el, url, 'audio/mpeg');
}



// link buttons and audio tags
const genreButtons = Array.from(document.querySelectorAll('#genre-controls .genre-btn'));
const audioEls = {
  techno: byId('audio-techno'),
  ambient: byId('audio-ambient'),
  electronic: byId('audio-electronic'),
  house: byId('audio-house'),
};

// status badge from previous UI (optional)
const statusEl = document.getElementById('reactiveStatus');

// make/keep one AudioReactiveEngine instance for these players
// if you already created `engine` earlier, reuse it; otherwise expose it:
window._audioReactiveEngine = window._audioReactiveEngine || (function () {
  // reuse the callbacks from earlier code:
  // if you kept them inside an IIFE, recreate minimal ones mapping to your sliders:
  const ranges = { height:{min:-10,max:10,dur:200}, threshold:{min:0.1,max:0.9,dur:300}, noise:{min:0.1,max:0.9,dur:100} };
  const clamp = (v,a,b)=>Math.min(b,Math.max(a,v));
  const mapRange=(v,i0,i1,o0,o1)=>o0+(Math.min(i1,Math.max(i0,v))-i0)*(o1-o0)/(i1-i0);

  const controllers = {
    height(val, fast=false){ animateController(heightSlider, parseFloat(heightSlider.value||0), clamp(val, ranges.height.min, ranges.height.max), fast?120:ranges.height.dur); },
    threshold(val, fast=false){ animateController(thresholdSlider, parseFloat(thresholdSlider.value||0.5), clamp(val, ranges.threshold.min, ranges.threshold.max), fast?140:ranges.threshold.dur); },
    noise(val, fast=false){ animateController(noiseAmountSlider, parseFloat(noiseAmountSlider.value||0.5), clamp(val, ranges.noise.min, ranges.noise.max), fast?100:ranges.noise.dur); },
  };
  const mapping = { kick:'height', snare:'threshold', loudness:'noise' };

  const onKick = () => {
    const r = ranges[mapping.kick]; const to = r.min + Math.random()*(r.max-r.min);
    controllers[mapping.kick](to, true);
  };
  const onSnare = () => {
    const r = ranges[mapping.snare]; const to = r.min + Math.random()*(r.max-r.min);
    controllers[mapping.snare](to, true);
  };
  const onLoudness = (lvl) => {
    const r = ranges[mapping.loudness];
    controllers[mapping.loudness](mapRange(lvl, 0.05, 0.35, r.min, r.max), false);
  };

  return new AudioReactiveEngine({ onKick, onSnare, onLoudness, statusEl });
})();

// wire each audio element into the engine when used
function connectAudioElToEngine(audioEl) {
  // if already connected once, just reuse; createMediaElementSource can only be used once per element
  if (!audioEl._connectedToEngine) {
    window._audioReactiveEngine.useFile(audioEl);
    audioEl._connectedToEngine = true;
  } else {
    // ensure analysis is running
    window._audioReactiveEngine.useFile(audioEl);
  }
}

// preload: assign one random track per genre (or the first if only one)
Object.entries(audioEls).forEach(([genre, el]) => {
  const list = SONGS[genre] || [];
  if (list.length) {
    el.src = list[randIdx(list)];
    // optional: advance to a new random track when one ends
    el.addEventListener('ended', () => {
      if (!SONGS[genre]?.length) return;
      el.src = SONGS[genre][randIdx(SONGS[genre])];
      el.play().catch(()=>{});
    });
  }
});

// state
let currentGenre = null;       // 'techno' | 'ambient' | 'electronic' | 'house' | null
let isPlaying = false;

// UI helpers
function setActiveButton(genre) {
  genreButtons.forEach(btn => {
    const g = btn.getAttribute('data-genre');
    if (g === genre && isPlaying) {
      btn.classList.add('btn-active'); // adjust to your CSS framework
      btn.textContent = btn.textContent.replace(/^(Play|Start|▶️)?/,'').trim();
      if (!/⏸/.test(btn.textContent)) btn.textContent = '⏸ ' + btn.textContent;
    } else {
      btn.classList.remove('btn-active');
      const label = btn.getAttribute('data-genre');
      const pretty = {
        techno: 'Techno | تکنو',
        ambient: 'Ambient | امبینت',
        electronic: 'Electronic | الکترونیک',
        house: 'House | هاوس'
      }[label] || label;
      btn.textContent = (currentGenre===g && !isPlaying ? '▶️ ' : '') + pretty;
    }
  });
}

// click logic: toggle play/stop; switch instantly when choosing a new genre
genreButtons.forEach(btn => {
  btn.addEventListener('click', async () => {
    const chosen = btn.getAttribute('data-genre');
    const chosenEl = audioEls[chosen];

    if (!SONGS[chosen]?.length) {
      if (statusEl) statusEl.textContent = `no tracks for ${chosen}`;
      return;
    }

    // if clicking the same genre: toggle play/pause
    if (currentGenre === chosen) {
      if (isPlaying) {
        chosenEl.pause();
        isPlaying = false;
        if (statusEl) statusEl.textContent = `${chosen} • paused`;
      } else {
        connectAudioElToEngine(chosenEl);
        try { await chosenEl.play(); isPlaying = true; if (statusEl) statusEl.textContent = `${chosen} • playing`; }
        catch(e){ console.warn(e); }
      }
      setActiveButton(chosen);
      return;
    }

    // switching genre: stop previous, start new instantly
    if (currentGenre) {
      const prevEl = audioEls[currentGenre];
      prevEl && prevEl.pause();
    }
    currentGenre = chosen;

    // if the chosen element has no src yet (lists can be dynamic), give it one
    if (!chosenEl.src) await setRandomTrack(chosen);

    connectAudioElToEngine(chosenEl);
    try {
      await chosenEl.play();
      isPlaying = true;
      if (statusEl) statusEl.textContent = `${chosen} • playing`;
    } catch (e) {
      isPlaying = false;
      if (statusEl) statusEl.textContent = `${chosen} • ready`;
      console.warn(e);
    }
    setActiveButton(chosen);
  });
});

</script>

</body>
</html>
